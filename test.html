<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU WGSL Density Function</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="webgpu-canvas"></canvas>
    <script type="module">
    // main.js
    async function initWebGPU() {
        if (!navigator.gpu) {
            console.error("WebGPU not supported on this browser.");
            return;
        }

        const canvas = document.getElementById("webgpu-canvas");
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();

        const context = canvas.getContext("webgpu");
        const format = navigator.gpu.getPreferredCanvasFormat();

        context.configure({
            device: device,
            format: format,
            alphaMode: "opaque"
        });

        // WGSL Shader Code
        // const shaderCode = `
        // @group(0) @binding(0) var<uniform> resolution: vec2<f32>;

        // // Vertex shader for full-screen quad
        // @vertex
        // fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
        //     // Positions for a full-screen quad in NDC coordinates using a triangle strip
        //     var positions = array<vec4<f32>, 5>(
        //         vec4<f32>(-1.0,  1.0, 0.0, 1.0), // Top-left
        //         vec4<f32>(-1.0, -1.0, 0.0, 1.0), // Bottom-left
        //         vec4<f32>( 1.0,  1.0, 0.0, 1.0), // Top-right
        //         vec4<f32>( 1.0, -1.0, 0.0, 1.0), // Bottom-right
        //         vec4<f32>(-1.0,  1.0, 0.0, 1.0), // Top-left
        //     );
        //     return positions[vertexIndex];
        // }

        // // Fragment shader to compute density
        // @fragment
        // fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
        //     // Convert pixel position to normalized device coordinates (NDC)
        //     let ndc = position.xy / resolution * 2.0 - 1.0;

        //     let dist = length(ndc);
        //     let density = 1.0 - dist;
        //     return vec4<f32>(density, density, density, 1.0);
        // }
        // `;

        const shaderCode = `
      struct OurVertexShaderOutput {
        @builtin(position) position: vec4f,
      };
 
      @vertex fn vs_main(
        @builtin(vertex_index) vertexIndex : u32
      ) -> OurVertexShaderOutput {
        let pos = array(
          vec2f( 0.0,  0.5),  // top center
          vec2f(-0.5, -0.5),  // bottom left
          vec2f( 0.5, -0.5)   // bottom right
        );
 
        var vsOutput: OurVertexShaderOutput;
        vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
        return vsOutput;
      }
 
      @fragment fn fs_main(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {
        let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);
 
        let grid = vec2u(fsInput.position.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;
 
        return select(red, cyan, checker);
      }
        `;

        const shaderModule = device.createShaderModule({
            code: shaderCode,
        });

        // Create the pipeline layout
        const pipelineLayout = device.createPipelineLayout({
            bindGroupLayouts: [device.createBindGroupLayout({
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" }
                }]
            })]
        });

        const pipeline = device.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
                module: shaderModule,
                entryPoint: "vs_main",
                buffers: []
            },
            fragment: {
                module: shaderModule,
                entryPoint: "fs_main",
                targets: [{
                    format: format
                }]
            },
            primitive: {
                topology: "triangle-list",
                stripIndexFormat: undefined
            }
        });

        const uniformBuffer = device.createBuffer({
            size: 2 * Float32Array.BYTES_PER_ELEMENT,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{
                binding: 0,
                resource: {
                    buffer: uniformBuffer
                }
            }]
        });

        function frame() {
            // Update the resolution uniform
            const resolution = new Float32Array([canvas.width, canvas.height]);
            device.queue.writeBuffer(uniformBuffer, 0, resolution.buffer);

            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView,
                    loadValue: { r: 0, g: 0, b: 0, a: 1 },
                    storeOp: "store",
                    loadOp: "clear",
                }]
            };

            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            // dunno why this doesnt work..
            // passEncoder.draw(4, 1, 0, 0); // Draw call
            // hotfix...
            passEncoder.draw(3, 1, 0, 0); // Draw call
            passEncoder.draw(4, 1, 1, 0); // Draw call
            passEncoder.end();

            device.queue.submit([commandEncoder.finish()]);

            requestAnimationFrame(frame);
        }

        frame();
    }

    window.addEventListener("load", initWebGPU);

    </script>
</body>
</html>
